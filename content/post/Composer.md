---
title: "Composer 自动加载解析"
date: 2020-03-22T16:14:11+08:00
archives: "2020"
tags: ['php','composer']
author: John SMITH
---

### Composer 自动加载分析以及优化

#### 自动加载的原理

自动加载的核心实现是依靠 spl_autoload_register 函数

spl_autoload_register 可以注册自动加载器到SPL __autoload函数队列中。用通俗一点的话说就是这个方法允许我们自己定义一个自动加载函数。

下面给出一个官方的例子
A.class.php
```php
<?php
class A
{
	function foo()
	{
		echo __CLASS__ . PHP_EOL;
	}
}
```
autoload.php
```php
<?php
spl_autoload_register(function ($class) {
	echo $class . PHP_EOL;
	$filename = $class . '.class.php';
	if (file_exists($filename)) {
    	include $filename;
	} else {
    	throw new Exception("Unable to load {$class}", 1);
	}
});

try {
	$obj = new A();
} catch (Exception $e) {
	echo $e->getMessage() . PHP_EOL;
}

```

上面的代码就注册了一个匿名函数来加载尚未引入文件的类。

现实环境中的代码比较复杂，我们会把类库放到不同的文件，使用不同的命名空间，自动加载实现就比上面的复杂一些，主要是在寻找文件上复杂一些。

#### Composer 的自动加载

Composer 的自动加载遵守了 PSR规范。

下面说一下 composer 自动加载的实现。

composer 版本 1.9.2

autoload.php (composer生成的自动加载器)
```
<?php
// autoload.php @generated by Composer

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInite71055bf03a04fd08e1e2c61c27d1437::getLoader();

```
这个是引用了autoload_real.php
然后获取自动加载器。

composer/autoload_real.php
```php
<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInite71055bf03a04fd08e1e2c61c27d1437
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }
	
	// 注册自动加载类(只是加载了一下加载器的类文件)
        spl_autoload_register(array('ComposerAutoloaderInite71055bf03a04fd08e1e2c61c27d1437', 'loadClassLoader'), true, true);
        // 实例化加载器
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        // 卸载掉刚才注册的加载器(真正生效的不是刚才注册的加载方法，而是ClassLoader里的register)
        spl_autoload_unregister(array('ComposerAutoloaderInite71055bf03a04fd08e1e2c61c27d1437', 'loadClassLoader'));
	
	// 判断是否使用静态加载器(PHP大于5.6并且没有使用HHVM并且没有使用 Zend Guard Loader)
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
        if ($useStaticLoader) {
            require_once __DIR__ . '/autoload_static.php';

            call_user_func(\Composer\Autoload\ComposerStaticInite71055bf03a04fd08e1e2c61c27d1437::getInitializer($loader));
        } else {
            // 设置PSR0自动加载的命名空间
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }
	    // 设置自动 PSR4 自动加载的命名空间
            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }
	    
	    // 类和目录关系映射
            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }
	
	// 注册自动加载器(这里才是加载扩展包的加载器)
        $loader->register(true);
	
	// 引入那些没有命名空间的文件
        if ($useStaticLoader) {
            $includeFiles = Composer\Autoload\ComposerStaticInite71055bf03a04fd08e1e2c61c27d1437::$files;
        } else {
            $includeFiles = require __DIR__ . '/autoload_files.php';
        }
        foreach ($includeFiles as $fileIdentifier => $file) {
            composerRequiree71055bf03a04fd08e1e2c61c27d1437($fileIdentifier, $file);
        }

        return $loader;
    }
}

function composerRequiree71055bf03a04fd08e1e2c61c27d1437($fileIdentifier, $file)
{
    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
        require $file;

        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
    }
}

```
composer/ClassLoader.php
```php
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 * @see    http://www.php-fig.org/psr/psr-0/
 * @see    http://www.php-fig.org/psr/psr-4/
 */
class ClassLoader
{
    ...
    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);
    }

    ...
    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return bool|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            includeFile($file);

            return true;
        }
    }
    
    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup(这里和下面的 Level 1相关，优化1的关键逻辑所在，生成类图后可以快速返回，不用再去扫文件了)
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        // 这里和 Level 2/A 相关
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        
        // 这里和 Level 2/B 相关
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }
    ...
    
}

/**
 * Scope isolated include.
 *
 * Prevents access to $this/self from included files.
 */
function includeFile($file)
{
    include $file;
}

```
自动加载器类，代码太长，只放了关键方法，loadClass 加载类，findFiles 找类名对应的文件地址， register 注册自动 loadClass 方法。
#### composer 的自动加载如何优化

* Level 1: 生成类图(类与文件映射关系，就是一个大数组里面有键是类名值是文件地址)
	1. 如何开启
		* composer.json 文件中设置 "optimize-autoloader": true
		* install 或者 update 时候带上参数 -o / --optimize-autoloader
		* 使用dump-autoload 带上参数 -o / --optimize
	2. 原理
		生成类图后就不用再起扫文件了，直接把类与文件关系映射缓存到 autoload_classmap.php 中，所以快很多，直接返回类对应的文件地址
	3. 缺点
		不会自动加载丢失的类，会爆出 not found 异常，这个问题优化 2 可以解决
* Level 2/A: 权威类图(Authoritative class maps)
	1. 如何使用
		* composer.json 文件中设置 "classmap-authoritative": true
		* install 或者 update 时候带上参数 -a / --classmap-authoritative
		* 使用dump-autoload 带上参数 -a / --classmap-authoritative
	2. 原理
		如果在类图中找不到这个类，那么这个类断定就不存在，不会继续在文件系统中寻找这个类
	3. 缺点
		这个优化与 Level 2/B 不共存
* Level 2/B: APCu 缓存 APCu Cache(类似于Opcache)
	1. 如何使用
		* composer.json 文件中设置 "apcu-autoloader": true
		* install 或者 update 时候带上参数 --apcu-autoloader
		* 使用dump-autoload 带上参数 --apcu-autoloader
	2. 原理
		如果在类图中找不到这个类，就去 APCu 缓存里找
	3. 缺点
		需要开启 APCu 扩展，这个优化与 Level 2/A 不共存
	
参考资料
[0] [类的自动加载](https://www.php.net/manual/zh/language.oop5.autoload.php) 
[1] [spl_autoload_register](https://www.php.net/manual/zh/function.spl-autoload-register.php) 
[2] [PSR](https://www.php-fig.org/psr/) 
[3] [composer](https://getcomposer.org/doc/articles/autoloader-optimization.md) 
[4] [APCu](https://www.php.net/manual/zh/book.apcu.php) 